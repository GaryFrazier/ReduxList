'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._basefunc = exports._isValidSchema = exports._isString = exports._isPromise = exports._isFunction = exports._isBoolean = exports._isInteger = exports._isNumber = exports._isArray = exports._isObject = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                              * Validation helpers for simple use cases
                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                              * @author  Avraam Mavridis      <avr.mav@gmail.com>
                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                              */


var _helpers = require('./helpers');

/**
 * Tests if the prop is an Object
 *
 * @method isObject
 *
 * @param  { any } prop
 *
 * @return { Boolean }
 */
var _isObject = exports._isObject = function _isObject(prop) {
  return (typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) === 'object' && prop !== null;
};

/**
 * Tests if something is an Array
 *
 * @type { Boolean }
 */
var _isArray = exports._isArray = Array.isArray;

/**
 * Tests if the prop is a number
 *
 * @method isNumber
 *
 * @param  { any } prop
 *
 * @return { Boolean }
 */
var _isNumber = exports._isNumber = function _isNumber(prop) {
  return typeof prop === 'number' && isFinite(prop);
};

/**
 * Tests if the prop is an integer
 *
 * @method inInteger
 *
 * @param  { any } prop
 *
 * @return { Boolean }
 */
var _isInteger = exports._isInteger = function _isInteger(prop) {
  return _isNumber(prop) && prop % 1 == 0;
};

/**
 * Tests if the prop is Boolean
 *
 * @method isBoolean
 *
 * @param  { any }  prop
 *
 * @return { Boolean }
 */
var _isBoolean = exports._isBoolean = function _isBoolean(prop) {
  return typeof prop === 'boolean';
};

/**
 * Tests if the prop is Function
 *
 * @method isBoolean
 *
 * @param  { any }  prop
 *
 * @return { Boolean }
 */
var _isFunction = exports._isFunction = function _isFunction(prop) {
  return typeof prop === 'function';
};

/**
 * Tests if the prop is a Promise
 *
 * @method isPromise
 *
 * @param  { any }  prop
 *
 * @return { Boolean }
 */
var _isPromise = exports._isPromise = function _isPromise(prop) {
  return prop !== null && ((typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) === 'object' || typeof prop === 'function') && typeof prop.then === 'function';
};

/**
 * Tests if the prop is a String
 *
 * @method isString
 *
 * @param  { any }  prop
 *
 * @return { Boolean }
 */
var _isString = exports._isString = function _isString(prop) {
  return typeof prop === 'string';
};

/**
 * validate a schema property
 *
 * @method _validateProperty
 *
 * @param  { any }          property
 * @param  { string }       type
 *
 * @return { boolean } or throws exception
 */
var _validateProperty = function _validateProperty(property, type) {
  var isValid = true;
  switch (type) {
    case 'object':
      isValid = _isObject(property);
      break;
    case 'number':
      isValid = _isNumber(property);
      break;
    case 'integer':
      isValid = _isInteger(property);
      break;
    case 'boolean':
      isValid = _isBoolean(property);
      break;
    case 'array':
      isValid = _isArray(property);
      break;
    case 'function':
      isValid = _isFunction(property);
      break;
    case 'string':
      isValid = _isString(property);
      break;
    case 'promise':
      isValid = _isPromise(property);
      break;
    default:
      throw Error(type + ' invalid type');
  }
  if (!isValid) {
    throw Error(property + ' is not ' + type);
  }
};

/**
 * validate against a schema
 *
 * @method isValidSchema
 *
 * @param  { object }      schema
 * @param  { number }      position = 0
 *
 * @return { Boolean }
 */
var _isValidSchema = exports._isValidSchema = function _isValidSchema(schema) {
  var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  var schemaKeys = Object.keys(schema);

  return function (target, key, descriptor) {
    var func = descriptor.value;
    descriptor.value = function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var prop = args[position];
      if (!_isObject(prop)) {
        throw Error(prop + ' is not an object');
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = schemaKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var schemaKey = _step.value;

          if (!prop.hasOwnProperty(schemaKey)) {
            throw Error('Object has not "' + schemaKey + '" property');
          }
          _validateProperty(prop[schemaKey], schema[schemaKey]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return func.apply(this, args);
    };
    return descriptor;
  };
};

/**
 * Returns the positions to validate
 *
 * @method _getPropsToValidate
 *
 * @param  {[type]}            position = 0  [description]
 * @param  {[type]}            args     = [] [description]
 *
 * @return {[type]}            [description]
 */
var _getPropsToValidate = function _getPropsToValidate() {
  var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  var positions = [].concat(position);
  var props = [];
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = positions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var p = _step2.value;

      if (!!args[p]) {
        props.push(args[p]);
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return props;
};

/**
 * Base decorator function for validation
 *
 * @method _basefunc
 *
 * @param  { integer }   position        Position of the property to validate
 * @param  { function }  validationFunc  Validation function
 * @param  { string }    errorMsg        Error message in case of invalid
 *
 * @return { function }  decorator function
 */
var _basefunc = exports._basefunc = function _basefunc() {
  var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var validationFunc = arguments[1];
  var errorMsg = arguments[2];
  var failSilent = arguments[3];


  return function (key, target, descriptor) {
    var func = descriptor.value;
    (0, _helpers.descriptorIsFunc)(key, func);
    descriptor.value = function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var props = _getPropsToValidate(position, args);
      props.forEach(function (prop) {
        if (!validationFunc(prop)) {
          if (failSilent) return;
          throw Error(prop + ' ' + errorMsg);
        }
      });
      return func.apply(this, args);
    };

    return descriptor;
  };
};